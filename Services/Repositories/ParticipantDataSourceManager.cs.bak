using ZealousMindedPeopleGeo.Models;
using ZealousMindedPeopleGeo.Interfaces;
using System.Collections.Concurrent;

namespace ZealousMindedPeopleGeo.Services.Repositories;

/// <summary>
/// Менеджер источников данных для участников
/// </summary>
public class ParticipantDataSourceManager // : IDataSourceManager, IDataSourceCompositionManager
{
    private readonly object _lock = new();
    private readonly ConcurrentDictionary<string, IParticipantDataSource> _dataSources = new();
    private readonly ParticipantDataSourceManagerConfiguration _configuration;
    private readonly List<IDataSourceDelegate> _delegates = new();
    
    public string Name { get; }
    public string Description { get; }
    public DataSourceManagerType ManagerType => DataSourceManagerType.Participant;
    public IEnumerable<string> RegisteredDataSourceNames => _dataSources.Keys.ToList();
    public IDataSourceConfiguration Configuration => _configuration;

    public event EventHandler<DataSourceEventArgs>? DataSourceAdded;
    public event EventHandler<DataSourceEventArgs>? DataSourceRemoved;
    public event EventHandler<DataSourceEventArgs>? DataSourceActivated;
    public event EventHandler<DataSourceEventArgs>? DataSourceDeactivated;
    public event EventHandler<CompositionStrategyChangedEventArgs>? CompositionStrategyChanged;

    /// <summary>
    /// Основной источник данных (приоритетный)
    /// </summary>
    public IParticipantDataSource? PrimaryDataSource { get; private set; }

    /// <summary>
    /// Текущая стратегия композиции источников данных
    /// </summary>
    public DataSourceCompositionStrategy CurrentCompositionStrategy { get; private set; }

    public ParticipantDataSourceManager(string name, ParticipantDataSourceManagerConfiguration? config = null)
    {
        Name = name ?? throw new ArgumentNullException(nameof(name));
        _configuration = config ?? new ParticipantDataSourceManagerConfiguration();
        _configuration.ManagerName = name;
        _configuration.PropertyChanged += OnConfigurationPropertyChanged;
        
        SetCompositionStrategy(_configuration.DefaultCompositionStrategy);
    }

    #region Управление источниками данных

    /// <summary>
    /// Регистрирует источник данных
    /// </summary>
    public async ValueTask<bool> RegisterDataSourceAsync(string name, IParticipantDataSource dataSource, bool setAsPrimary = false)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Имя источника данных не может быть пустым", nameof(name));

        if (dataSource == null)
            throw new ArgumentNullException(nameof(dataSource));

        try
        {
            // Проверяем доступность источника
            var isAvailable = await dataSource.IsAvailableAsync();
            if (!isAvailable && _configuration.RequireAvailableDataSources)
            {
                return false;
            }

            lock (_lock)
            {
                if (_dataSources.ContainsKey(name))
                {
                    return false;
                }

                _dataSources[name] = dataSource;
                
                if (setAsPrimary || PrimaryDataSource == null)
                {
                    SetPrimaryDataSource(dataSource);
                }
            }

            // Уведомляем делегатов
            NotifyDelegates(d => d.OnDataSourceRegistered?.Invoke(this, new DataSourceEventArgs(name, dataSource)));

            // Вызываем событие
            DataSourceAdded?.Invoke(this, new DataSourceEventArgs(name, dataSource));

            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Отменяет регистрацию источника данных
    /// </summary>
    public async ValueTask<bool> UnregisterDataSourceAsync(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return false;

        try
        {
            IParticipantDataSource removedSource = null!;
            
            lock (_lock)
            {
                if (_dataSources.TryRemove(name, out var dataSource))
                {
                    removedSource = dataSource;
                }
                else
                {
                    return false;
                }
            }

            // Если удаляемый источник был основным, выбираем новый основной
            if (PrimaryDataSource == removedSource)
            {
                await SelectNewPrimaryDataSourceAsync();
            }

            // Уведомляем делегатов
            NotifyDelegates(d => d.OnDataSourceUnregistered?.Invoke(this, new DataSourceEventArgs(name, removedSource)));

            // Вызываем событие
            DataSourceRemoved?.Invoke(this, new DataSourceEventArgs(name, removedSource));

            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Получает источник данных по имени
    /// </summary>
    public IParticipantDataSource? GetDataSource(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return null;

        _dataSources.TryGetValue(name, out var dataSource);
        return dataSource;
    }

    /// <summary>
    /// Получает список всех зарегистрированных источников данных
    /// </summary>
    public IEnumerable<IParticipantDataSource> GetAllDataSources()
    {
        lock (_lock)
        {
            return _dataSources.Values.ToList();
        }
    }

    /// <summary>
    /// Проверяет доступность всех источников данных
    /// </summary>
    public async ValueTask<IDictionary<string, bool>> CheckDataSourcesAvailabilityAsync(CancellationToken ct = default)
    {
        var results = new ConcurrentDictionary<string, bool>();
        var tasks = _dataSources.Select(async kvp =>
        {
            try
            {
                var isAvailable = await kvp.Value.IsAvailableAsync(ct);
                results[kvp.Key] = isAvailable;
            }
            catch
            {
                results[kvp.Key] = false;
            }
        });

        await Task.WhenAll(tasks);
        return results.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    #endregion

    #region Управление основным источником данных

    /// <summary>
    /// Устанавливает основной источник данных
    /// </summary>
    public void SetPrimaryDataSource(IParticipantDataSource dataSource)
    {
        if (dataSource == null)
            throw new ArgumentNullException(nameof(dataSource));

        var oldPrimary = PrimaryDataSource;
        PrimaryDataSource = dataSource;

        // Деактивируем старый основной источник
        if (oldPrimary != null && oldPrimary != dataSource)
        {
            DataSourceDeactivated?.Invoke(this, new DataSourceEventArgs("primary", oldPrimary));
        }

        // Активируем новый основной источник
        DataSourceActivated?.Invoke(this, new DataSourceEventArgs("primary", dataSource));
    }

    /// <summary>
    /// Устанавливает основной источник данных по имени
    /// </summary>
    public async ValueTask<bool> SetPrimaryDataSourceAsync(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return false;

        if (_dataSources.TryGetValue(name, out var dataSource))
        {
            var isAvailable = await dataSource.IsAvailableAsync();
            if (isAvailable || !_configuration.RequireAvailableDataSources)
            {
                SetPrimaryDataSource(dataSource);
                return true;
            }
        }

        return false;
    }

    private async Task SelectNewPrimaryDataSourceAsync()
    {
        lock (_lock)
        {
            if (_dataSources.Count > 0)
            {
                // Выбираем источник с наивысшим приоритетом
                var bestDataSource = _dataSources.Values
                    .OrderByDescending(ds => ds.Priority)
                    .FirstOrDefault();
                
                if (bestDataSource != null)
                {
                    PrimaryDataSource = bestDataSource;
                }
            }
            else
            {
                PrimaryDataSource = null;
            }
        }
    }

    #endregion

    #region Композиция источников данных

    /// <summary>
    /// Устанавливает стратегию композиции источников данных
    /// </summary>
    public void SetCompositionStrategy(DataSourceCompositionStrategy strategy)
    {
        var oldStrategy = CurrentCompositionStrategy;
        CurrentCompositionStrategy = strategy;

        CompositionStrategyChanged?.Invoke(this, new CompositionStrategyChangedEventArgs(oldStrategy, strategy));
    }

    /// <summary>
    /// Выполняет операцию с композицией источников данных
    /// </summary>
    public async ValueTask<T> ExecuteWithCompositionAsync<T>(DataSourceOperation operation, Func<IParticipantDataSource, ValueTask<T>> operationFunc)
    {
        if (operationFunc == null)
            throw new ArgumentNullException(nameof(operationFunc));

        switch (CurrentCompositionStrategy)
        {
            case DataSourceCompositionStrategy.UsePrimaryOnly:
                return await ExecuteWithPrimaryDataSourceAsync(operationFunc);

            case DataSourceCompositionStrategy.UseAllAndMerge:
                return await ExecuteWithAllDataSourcesAndMergeAsync(operation, operationFunc);

            case DataSourceCompositionStrategy.UseFirstAvailable:
                return await ExecuteWithFirstAvailableDataSourceAsync(operationFunc);

            case DataSourceCompositionStrategy.UsePriorityBased:
                return await ExecuteWithPriorityBasedDataSourceAsync(operationFunc);

            default:
                throw new NotSupportedException($"Стратегия {CurrentCompositionStrategy} не поддерживается");
        }
    }

    /// <summary>
    /// Выполняет операцию только с основным источником данных
    /// </summary>
    private async ValueTask<T> ExecuteWithPrimaryDataSourceAsync<T>(Func<IParticipantDataSource, ValueTask<T>> operationFunc)
    {
        if (PrimaryDataSource == null)
            throw new InvalidOperationException("Основной источник данных не установлен");

        return await operationFunc(PrimaryDataSource);
    }

    /// <summary>
    /// Выполняет операцию с первым доступным источником данных
    /// </summary>
    private async ValueTask<T> ExecuteWithFirstAvailableDataSourceAsync<T>(Func<IParticipantDataSource, ValueTask<T>> operationFunc)
    {
        lock (_lock)
        {
            var dataSources = _dataSources.Values.ToList();
        }

        foreach (var dataSource in dataSources.OrderBy(ds => ds.Priority))
        {
            try
            {
                var isAvailable = await dataSource.IsAvailableAsync();
                if (isAvailable)
                {
                    return await operationFunc(dataSource);
                }
            }
            catch
            {
                continue;
            }
        }

        throw new InvalidOperationException("Нет доступных источников данных");
    }

    /// <summary>
    /// Выполняет операцию с источником данных с наивысшим приоритетом
    /// </summary>
    private async ValueTask<T> ExecuteWithPriorityBasedDataSourceAsync<T>(Func<IParticipantDataSource, ValueTask<T>> operationFunc)
    {
        IParticipantDataSource? bestDataSource = null;
        int highestPriority = int.MinValue;

        lock (_lock)
        {
            foreach (var dataSource in _dataSources.Values)
            {
                if (dataSource.Priority > highestPriority)
                {
                    highestPriority = dataSource.Priority;
                    bestDataSource = dataSource;
                }
            }
        }

        if (bestDataSource == null)
            throw new InvalidOperationException("Нет зарегистрированных источников данных");

        var isAvailable = await bestDataSource.IsAvailableAsync();
        if (!isAvailable && _configuration.RequireAvailableDataSources)
        {
            throw new InvalidOperationException("Приоритетный источник данных недоступен");
        }

        return await operationFunc(bestDataSource);
    }

    /// <summary>
    /// Выполняет операцию со всеми источниками данных и объединяет результаты
    /// </summary>
    private async ValueTask<T> ExecuteWithAllDataSourcesAndMergeAsync<T>(DataSourceOperation operation, Func<IParticipantDataSource, ValueTask<T>> operationFunc)
    {
        // Этот метод реализуется в зависимости от типа операции и результата
        // Для каждой операции может быть своя логика объединения результатов
        throw new NotImplementedException("Объединение результатов всех источников данных будет реализовано в зависимости от операции");
    }

    #endregion

    #region Делегаты

    /// <summary>
    /// Добавляет делегат источника данных
    /// </summary>
    public void AddDelegate(IDataSourceDelegate dataSourceDelegate)
    {
        if (dataSourceDelegate == null)
            throw new ArgumentNullException(nameof(dataSourceDelegate));

        lock (_lock)
        {
            if (!_delegates.Contains(dataSourceDelegate))
            {
                _delegates.Add(dataSourceDelegate);
            }
        }
    }

    /// <summary>
    /// Удаляет делегат источника данных
    /// </summary>
    public void RemoveDelegate(IDataSourceDelegate dataSourceDelegate)
    {
        if (dataSourceDelegate == null)
            return;

        lock (_lock)
        {
            _delegates.Remove(dataSourceDelegate);
        }
    }

    private void NotifyDelegates(Action<IDataSourceDelegate> action)
    {
        lock (_lock)
        {
            foreach (var item in _delegates)
            {
                try
                {
                    action(item);
                }
                catch
                {
                    // Игнорируем ошибки делегатов
                }
            }
        }
    }

    #endregion

    #region Операции с участниками через композицию

    /// <summary>
    /// Получает всех участников с использованием текущей стратегии композиции
    /// </summary>
    public async ValueTask<IEnumerable<Participant>> GetAllParticipantsAsync(CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        return await ExecuteWithCompositionAsync(
            DataSourceOperation.Read,
            ds => ds.GetAllParticipantsAsync(ct)
        );
    }

    /// <summary>
    /// Получает участника по ID с использованием текущей стратегии композиции
    /// </summary>
    public async ValueTask<Participant?> GetParticipantByIdAsync(Guid id, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        return await ExecuteWithCompositionAsync(
            DataSourceOperation.Read,
            ds => ds.GetParticipantByIdAsync(id, ct)
        );
    }

    /// <summary>
    /// Добавляет участника с использованием текущей стратегии композиции
    /// </summary>
    public async ValueTask<RepositoryResult> AddParticipantAsync(Participant participant, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        return await ExecuteWithCompositionAsync(
            DataSourceOperation.Create,
            ds => ds.AddParticipantAsync(participant, ct)
        );
    }

    /// <summary>
    /// Обновляет участника с использованием текущей стратегии композиции
    /// </summary>
    public async ValueTask<RepositoryResult> UpdateParticipantAsync(Participant participant, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        return await ExecuteWithCompositionAsync(
            DataSourceOperation.Update,
            ds => ds.UpdateParticipantAsync(participant, ct)
        );
    }

    /// <summary>
    /// Удаляет участника с использованием текущей стратегии композиции
    /// </summary>
    public async ValueTask<RepositoryResult> DeleteParticipantAsync(Guid id, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        return await ExecuteWithCompositionAsync(
            DataSourceOperation.Delete,
            ds => ds.DeleteParticipantAsync(id, ct)
        );
    }

    /// <summary>
    /// Ищет участников с использованием текущей стратегии композиции
    /// </summary>
    public async ValueTask<IEnumerable<Participant>> FindParticipantsAsync(Func<Participant, bool> predicate, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        return await ExecuteWithCompositionAsync(
            DataSourceOperation.Read,
            ds => ds.FindParticipantsAsync(predicate, ct)
        );
    }

    /// <summary>
    /// Получает количество участников с использованием текущей стратегии композиции
    /// </summary>
    public async ValueTask<int> GetParticipantCountAsync(CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        return await ExecuteWithCompositionAsync(
            DataSourceOperation.Read,
            ds => ds.GetParticipantCountAsync(ct)
        );
    }

    #endregion

    #region Статистика и мониторинг

    /// <summary>
    /// Получает агрегированную статистику всех источников данных
    /// </summary>
    public async ValueTask<IDictionary<string, DataSourceStatistics>> GetStatisticsAsync(CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        var statistics = new ConcurrentDictionary<string, DataSourceStatistics>();
        var tasks = _dataSources.Select(async kvp =>
        {
            try
            {
                var stats = await kvp.Value.GetStatisticsAsync(ct);
                statistics[kvp.Key] = stats;
            }
            catch
            {
                statistics[kvp.Key] = new DataSourceStatistics
                {
                    Status = DataSourceStatus.Error,
                    StatusMessage = "Ошибка получения статистики"
                };
            }
        });

        await Task.WhenAll(tasks);
        return statistics.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    /// <summary>
    /// Получает общее количество участников из всех источников
    /// </summary>
    public async ValueTask<int> GetTotalParticipantCountAsync(CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        try
        {
            var tasks = _dataSources.Values.Select(ds => ds.GetParticipantCountAsync(ct));
            var counts = await Task.WhenAll(tasks);
            return counts.Sum();
        }
        catch
        {
            return 0;
        }
    }

    /// <summary>
    /// Получает отчет о состоянии источников данных
    /// </summary>
    public async ValueTask<DataSourceManagerStatusReport> GetStatusReportAsync(CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        var availability = await CheckDataSourcesAvailabilityAsync(ct);
        var statistics = await GetStatisticsAsync(ct);
        var totalParticipants = await GetTotalParticipantCountAsync(ct);

        var availableCount = availability.Values.Count(v => v);
        var totalCount = availability.Count;

        var report = new DataSourceManagerStatusReport
        {
            ManagerName = Name,
            TotalDataSources = totalCount,
            AvailableDataSources = availableCount,
            PrimaryDataSourceName = PrimaryDataSource?.Name ?? "Не установлен",
            CompositionStrategy = CurrentCompositionStrategy.ToString(),
            TotalParticipants = totalParticipants,
            Status = availableCount > 0 ? DataSourceManagerStatus.Operational : DataSourceManagerStatus.Degraded,
            StatusMessage = availableCount > 0 
                ? $"Операционен: {availableCount}/{totalCount} источников доступны"
                : "Недоступен: ни один источник данных недоступен",
            SourceAvailability = availability,
            SourceStatistics = statistics
        };

        return report;
    }

    #endregion

    #region Синхронизация и резервное копирование

    /// <summary>
    /// Создает резервную копию всех данных
    /// </summary>
    public async ValueTask<bool> CreateBackupAsync(string backupPath, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        if (string.IsNullOrWhiteSpace(backupPath))
            return false;

        try
        {
            // Создаем директорию для резервной копии если она не существует
            var directory = Path.GetDirectoryName(backupPath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            var report = await GetStatusReportAsync(ct);
            var backupData = new
            {
                Timestamp = DateTime.UtcNow,
                ManagerName = Name,
                Report = report,
                Participants = await GetAllParticipantsAsync(ct)
            };

            var options = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            var jsonContent = JsonSerializer.Serialize(backupData, options);
            await File.WriteAllTextAsync(backupPath, jsonContent, ct);

            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Восстанавливает данные из резервной копии
    /// </summary>
    public async ValueTask<RestoreResult> RestoreFromBackupAsync(string backupPath, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        if (string.IsNullOrWhiteSpace(backupPath) || !File.Exists(backupPath))
        {
            return new RestoreResult
            {
                Success = false,
                ErrorMessage = "Файл резервной копии не найден"
            };
        }

        try
        {
            var jsonContent = await File.ReadAllTextAsync(backupPath, ct);
            var backupData = JsonSerializer.Deserialize<JsonElement>(jsonContent);

            if (!backupData.TryGetProperty("Participants", out var participantsElement))
            {
                return new RestoreResult
                {
                    Success = false,
                    ErrorMessage = "Некорректный формат резервной копии"
                };
            }

            var participants = JsonSerializer.Deserialize<List<Participant>>(participantsElement.GetRawText());
            if (participants == null)
            {
                return new RestoreResult
                {
                    Success = false,
                    ErrorMessage = "Не удалось десериализовать участников"
                };
            }

            // Восстанавливаем в основной источник данных
            if (PrimaryDataSource != null)
            {
                var cleared = false;
                foreach (var participant in participants)
                {
                    var result = await PrimaryDataSource.AddParticipantAsync(participant, ct);
                    if (!result.Success && !cleared)
                    {
                        // Попробуем обновить если участник уже существует
                        await PrimaryDataSource.UpdateParticipantAsync(participant, ct);
                    }
                }

                return new RestoreResult
                {
                    Success = true,
                    RestoredCount = participants.Count
                };
            }

            return new RestoreResult
            {
                Success = false,
                ErrorMessage = "Основной источник данных не установлен"
            };
        }
        catch (Exception ex)
        {
            return new RestoreResult
            {
                Success = false,
                ErrorMessage = $"Ошибка восстановления: {ex.Message}"
            };
        }
    }

    #endregion

    #region Служебные методы

    private void OnConfigurationPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(ParticipantDataSourceManagerConfiguration.DefaultCompositionStrategy))
        {
            SetCompositionStrategy(_configuration.DefaultCompositionStrategy);
        }
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        _configuration.PropertyChanged -= OnConfigurationPropertyChanged;
        
        lock (_lock)
        {
            _delegates.Clear();
            _dataSources.Clear();
        }
    }

    #endregion
}

/// <summary>
/// Конфигурация менеджера источников данных для участников
/// </summary>
public class ParticipantDataSourceManagerConfiguration : IDataSourceConfiguration
{
    public string? ConnectionString { get; set; }
    public Dictionary<string, object> Settings { get; set; } = new();
    public int TimeoutSeconds { get; set; } = 30;
    public int MaxRetries { get; set; } = 3;
    public int RetryDelayMs { get; set; } = 1000;

    /// <summary>
    /// Имя менеджера источников данных
    /// </summary>
    public string ManagerName { get; internal set; } = "";

    /// <summary>
    /// Требовать доступность источников данных при регистрации
    /// </summary>
    public bool RequireAvailableDataSources { get; set; } = false;

    /// <summary>
    /// Стратегия композиции источников данных по умолчанию
    /// </summary>
    public DataSourceCompositionStrategy DefaultCompositionStrategy { get; set; } = DataSourceCompositionStrategy.UsePriorityBased;

    /// <summary>
    /// Включить автоматическое создание источника данных In-Memory если нет других
    /// </summary>
    public bool AutoCreateInMemorySource { get; set; } = true;

    /// <summary>
    /// Максимальное количество источников данных
    /// </summary>
    public int MaxDataSources { get; set; } = 10;

    /// <summary>
    /// Автоматически создавать резервные копии
    /// </summary>
    public bool AutoBackup { get; set; } = false;

    /// <summary>
    /// Интервал автоматического создания резервных копий (в минутах)
    /// </summary>
    public int BackupIntervalMinutes { get; set; } = 60;

    /// <summary>
    /// Включить подробное логирование операций
    /// </summary>
    public bool EnableDetailedLogging { get; set; } = false;
}

/// <summary>
/// Отчет о состоянии менеджера источников данных
/// </summary>
public class DataSourceManagerStatusReport
{
    public string ManagerName { get; set; } = "";
    public int TotalDataSources { get; set; }
    public int AvailableDataSources { get; set; }
    public string PrimaryDataSourceName { get; set; } = "";
    public string CompositionStrategy { get; set; } = "";
    public int TotalParticipants { get; set; }
    public DataSourceManagerStatus Status { get; set; }
    public string StatusMessage { get; set; } = "";
    public IDictionary<string, bool> SourceAvailability { get; set; } = new Dictionary<string, bool>();
    public IDictionary<string, DataSourceStatistics> SourceStatistics { get; set; } = new Dictionary<string, DataSourceStatistics>();
    public DateTime GeneratedAt { get; set; } = DateTime.UtcNow;
}