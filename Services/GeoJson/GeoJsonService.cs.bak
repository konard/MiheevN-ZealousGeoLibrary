using System.Text.Json;
using ZealousMindedPeopleGeo.Models;
using ZealousMindedPeopleGeo.Interfaces;

namespace ZealousMindedPeopleGeo.Services.GeoJson;

/// <summary>
/// Сервис для работы с GeoJSON данными участников
/// </summary>
public class GeoJsonService : IGeoJsonService
{
    private readonly GeoJsonServiceConfiguration _configuration;
    private readonly GeoJsonStatistics _statistics;

    public string Name => "GeoJSON Data Service";
    public string Description => "Сервис для работы с GeoJSON данными участников";
    public IGeoJsonServiceConfiguration Configuration => _configuration;

    public event EventHandler<GeoJsonEventArgs>? GeoJsonProcessingStarted;
    public event EventHandler<GeoJsonEventArgs>? GeoJsonProcessingCompleted;
    public event EventHandler<GeoJsonErrorEventArgs>? GeoJsonProcessingError;

    public GeoJsonService(GeoJsonServiceConfiguration? config = null)
    {
        _configuration = config ?? new GeoJsonServiceConfiguration();
        _statistics = new GeoJsonStatistics();
    }

    /// <summary>
    /// Валидирует GeoJSON строку
    /// </summary>
    public ValidationResult ValidateGeoJson(string geoJsonString)
    {
        if (string.IsNullOrWhiteSpace(geoJsonString))
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = "GeoJSON строка не может быть пустой"
            };
        }

        try
        {
            // Базовая JSON валидация
            var document = JsonDocument.Parse(geoJsonString);
            var root = document.RootElement;

            // Проверяем наличие обязательного свойства "type"
            if (!root.TryGetProperty("type", out var typeProperty))
            {
                return new ValidationResult
                {
                    IsValid = false,
                    ErrorMessage = "Отсутствует обязательное свойство 'type'"
                };
            }

            var type = typeProperty.GetString();
            if (type != "Feature" && type != "FeatureCollection")
            {
                return new ValidationResult
                {
                    IsValid = false,
                    ErrorMessage = $"Неподдерживаемый тип GeoJSON: {type}. Поддерживаются только 'Feature' и 'FeatureCollection'"
                };
            }

            // Валидируем FeatureCollection
            if (type == "FeatureCollection")
            {
                return ValidateFeatureCollection(root);
            }
            // Валидируем Feature
            else
            {
                return ValidateFeature(root);
            }
        }
        catch (JsonException ex)
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = $"Некорректный JSON: {ex.Message}"
            };
        }
        catch (Exception ex)
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = $"Ошибка валидации: {ex.Message}"
            };
        }
    }

    /// <summary>
    /// Создает GeoJSON Feature из участника
    /// </summary>
    public GeoJsonFeature CreateFeatureFromParticipant(Participant participant)
    {
        if (participant == null)
            throw new ArgumentNullException(nameof(participant));

        if (participant.Coordinates == null)
            throw new ArgumentException("У участника должны быть указаны координаты", nameof(participant));

        return new GeoJsonFeature
        {
            Type = "Feature",
            Geometry = new GeoJsonGeometry
            {
                Type = "Point",
                Coordinates = new[]
                {
                    participant.Coordinates.Longitude,
                    participant.Coordinates.Latitude
                }
            },
            Properties = new Dictionary<string, object>
            {
                { "id", participant.Id.ToString() },
                { "name", participant.Name ?? "" },
                { "description", participant.Description ?? "" },
                { "category", participant.Category ?? "" },
                { "language", participant.Language ?? "" },
                { "country", participant.Country ?? "" },
                { "city", participant.City ?? "" },
                { "organization", participant.Organization ?? "" },
                { "position", participant.Position ?? "" },
                { "email", participant.Email ?? "" },
                { "website", participant.Website ?? "" },
                { "interests", participant.Interests ?? "" },
                { "skills", participant.Skills ?? "" },
                { "availability", participant.Availability ?? "" },
                { "status", participant.Status?.ToString() ?? "" },
                { "registrationDate", participant.RegistrationDate.ToString("O") },
                { "lastActive", participant.LastActive?.ToString("O") ?? "" },
                { "tags", participant.Tags ?? "" },
                { "metadata", participant.Metadata ?? "" }
            }
        };
    }

    /// <summary>
    /// Создает коллекцию Feature из списка участников
    /// </summary>
    public GeoJsonFeatureCollection CreateFeatureCollectionFromParticipants(IEnumerable<Participant> participants)
    {
        if (participants == null)
            throw new ArgumentNullException(nameof(participants));

        var participantList = participants.ToList();
        var features = new List<GeoJsonFeature>();
        var validFeatures = 0;

        foreach (var participant in participantList)
        {
            try
            {
                var feature = CreateFeatureFromParticipant(participant);
                features.Add(feature);
                validFeatures++;
            }
            catch (Exception ex)
            {
                // Логируем ошибку и продолжаем
                System.Diagnostics.Debug.WriteLine($"Ошибка создания feature для участника {participant.Id}: {ex.Message}");
            }
        }

        return new GeoJsonFeatureCollection
        {
            Type = "FeatureCollection",
            Features = features,
            Metadata = new GeoJsonMetadata
            {
                GeneratedAt = DateTime.UtcNow,
                TotalFeatures = participantList.Count,
                ValidFeatures = validFeatures,
                Source = _configuration.SourceName,
                CoordinateReferenceSystem = "EPSG:4326",
                SchemaVersion = _configuration.SchemaVersion,
                BoundingBox = CalculateBoundingBox(features),
                Notes = _configuration.Notes
            }
        };
    }

    /// <summary>
    /// Извлекает участников из GeoJSON коллекции
    /// </summary>
    public IEnumerable<Participant> ExtractParticipantsFromGeoJson(string geoJsonString)
    {
        var validation = ValidateGeoJson(geoJsonString);
        if (!validation.IsValid)
        {
            throw new InvalidOperationException($"Некорректный GeoJSON: {validation.ErrorMessage}");
        }

        try
        {
            var document = JsonDocument.Parse(geoJsonString);
            var root = document.RootElement;

            if (root.TryGetProperty("type", out var typeProperty))
            {
                var type = typeProperty.GetString();
                if (type == "Feature")
                {
                    var feature = JsonSerializer.Deserialize<GeoJsonFeature>(root.GetRawText());
                    var participant = CreateParticipantFromFeature(feature);
                    return participant != null ? new[] { participant } : Enumerable.Empty<Participant>();
                }
                else if (type == "FeatureCollection")
                {
                    var collection = JsonSerializer.Deserialize<GeoJsonFeatureCollection>(root.GetRawText());
                    if (collection?.Features != null)
                    {
                        var participants = new List<Participant>();
                        foreach (var feature in collection.Features)
                        {
                            var participant = CreateParticipantFromFeature(feature);
                            if (participant != null)
                            {
                                participants.Add(participant);
                            }
                        }
                        return participants;
                    }
                }
            }

            return Enumerable.Empty<Participant>();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Ошибка извлечения участников из GeoJSON: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Сериализует GeoJSON в строку с форматированием
    /// </summary>
    public string SerializeGeoJson(GeoJsonFeatureCollection collection, bool prettyPrint = true)
    {
        if (collection == null)
            throw new ArgumentNullException(nameof(collection));

        var options = new JsonSerializerOptions
        {
            WriteIndented = prettyPrint,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        return JsonSerializer.Serialize(collection, options);
    }

    /// <summary>
    /// Десериализует GeoJSON из строки
    /// </summary>
    public GeoJsonFeatureCollection? DeserializeGeoJson(string geoJsonString)
    {
        if (string.IsNullOrWhiteSpace(geoJsonString))
            return null;

        try
        {
            return JsonSerializer.Deserialize<GeoJsonFeatureCollection>(geoJsonString);
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Фильтрует участников по географическим критериям
    /// </summary>
    public IEnumerable<Participant> FilterParticipantsByGeoJson(string geoJsonString, IEnumerable<Participant> participants)
    {
        var filteredParticipants = new List<Participant>();
        var collection = DeserializeGeoJson(geoJsonString);

        if (collection?.Features == null)
            return participants;

        try
        {
            foreach (var participant in participants)
            {
                if (IsParticipantInGeoJsonArea(participant, collection))
                {
                    filteredParticipants.Add(participant);
                }
            }
        }
        catch (Exception ex)
        {
            // Логируем ошибку и возвращаем исходный список
            System.Diagnostics.Debug.WriteLine($"Ошибка фильтрации по GeoJSON: {ex.Message}");
        }

        return filteredParticipants;
    }

    /// <summary>
    /// Выполняет пространственный запрос участников
    /// </summary>
    public async ValueTask<SpatialQueryResult> PerformSpatialQueryAsync(SpatialQuery query, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        if (query == null)
            throw new ArgumentNullException(nameof(query));

        var result = new SpatialQueryResult
        {
            Query = query,
            ExecutedAt = DateTime.UtcNow
        };

        try
        {
            // Здесь можно реализовать различные типы пространственных запросов
            // Например, поиск в радиусе, поиск по границам, пересечение полигонов и т.д.
            
            switch (query.QueryType)
            {
                case SpatialQueryType.WithinRadius:
                    result = await PerformRadiusQueryAsync(query, ct);
                    break;
                case SpatialQueryType.WithinBbox:
                    result = await PerformBboxQueryAsync(query, ct);
                    break;
                case SpatialQueryType.Intersects:
                    result = await PerformIntersectsQueryAsync(query, ct);
                    break;
                default:
                    throw new NotSupportedException($"Тип запроса {query.QueryType} не поддерживается");
            }

            return result;
        }
        catch (Exception ex)
        {
            result.IsSuccess = false;
            result.ErrorMessage = $"Ошибка выполнения пространственного запроса: {ex.Message}";
            return result;
        }
    }

    /// <summary>
    /// Получает статистику GeoJSON данных
    /// </summary>
    public GeoJsonStatistics GetStatistics(string geoJsonString)
    {
        try
        {
            var document = JsonDocument.Parse(geoJsonString);
            var root = document.RootElement;

            _statistics.LastAnalyzedAt = DateTime.UtcNow;

            if (root.TryGetProperty("type", out var typeProperty))
            {
                _statistics.GeoJsonType = typeProperty.GetString() ?? "Unknown";

                if (root.TryGetProperty("features", out var featuresProperty) && featuresProperty.ValueKind == JsonValueKind.Array)
                {
                    _statistics.FeatureCount = featuresProperty.GetArrayLength();
                }
            }

            // Подсчитываем различные типы геометрий
            if (root.TryGetProperty("features", out var featuresProp))
            {
                foreach (var feature in featuresProp.EnumerateArray())
                {
                    if (feature.TryGetProperty("geometry", out var geometry))
                    {
                        if (geometry.TryGetProperty("type", out var geomType))
                        {
                            var type = geomType.GetString();
                            switch (type)
                            {
                                case "Point":
                                    _statistics.PointCount++;
                                    break;
                                case "LineString":
                                    _statistics.LineStringCount++;
                                    break;
                                case "Polygon":
                                    _statistics.PolygonCount++;
                                    break;
                                case "MultiPoint":
                                    _statistics.MultiPointCount++;
                                    break;
                                case "MultiLineString":
                                    _statistics.MultiLineStringCount++;
                                    break;
                                case "MultiPolygon":
                                    _statistics.MultiPolygonCount++;
                                    break;
                                case "GeometryCollection":
                                    _statistics.GeometryCollectionCount++;
                                    break;
                            }
                        }
                    }
                }
            }

            return _statistics.Clone();
        }
        catch
        {
            return _statistics.Clone();
        }
    }

    private ValidationResult ValidateFeatureCollection(JsonElement root)
    {
        // Проверяем наличие массива features
        if (!root.TryGetProperty("features", out var featuresProperty) || featuresProperty.ValueKind != JsonValueKind.Array)
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = "FeatureCollection должен содержать массив 'features'"
            };
        }

        // Валидируем каждый feature
        var validFeatures = 0;
        var totalFeatures = featuresProperty.GetArrayLength();

        foreach (var feature in featuresProperty.EnumerateArray())
        {
            var featureValidation = ValidateFeature(feature);
            if (featureValidation.IsValid)
            {
                validFeatures++;
            }
        }

        return new ValidationResult
        {
            IsValid = validFeatures > 0,
            WarningMessage = validFeatures < totalFeatures 
                ? $"Только {validFeatures} из {totalFeatures} features валидны"
                : null
        };
    }

    private ValidationResult ValidateFeature(JsonElement feature)
    {
        // Проверяем наличие geometry
        if (!feature.TryGetProperty("geometry", out var geometry))
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = "Feature должен содержать property 'geometry'"
            };
        }

        // Проверяем корректность геометрии
        var geometryValidation = ValidateGeometry(geometry);
        if (!geometryValidation.IsValid)
        {
            return geometryValidation;
        }

        return new ValidationResult { IsValid = true };
    }

    private ValidationResult ValidateGeometry(JsonElement geometry)
    {
        // Проверяем наличие типа геометрии
        if (!geometry.TryGetProperty("type", out var typeProperty))
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = "Geometry должен содержать property 'type'"
            };
        }

        var type = typeProperty.GetString();
        var supportedTypes = new[] { "Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection" };

        if (!supportedTypes.Contains(type))
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = $"Неподдерживаемый тип геометрии: {type}"
            };
        }

        // Проверяем наличие координат
        if (!geometry.TryGetProperty("coordinates", out var coordinates))
        {
            return new ValidationResult
            {
                IsValid = false,
                ErrorMessage = "Geometry должен содержать property 'coordinates'"
            };
        }

        // Базовая валидация координат для Point
        if (type == "Point" && coordinates.ValueKind == JsonValueKind.Array)
        {
            var coords = coordinates.EnumerateArray().ToArray();
            if (coords.Length != 2)
            {
                return new ValidationResult
                {
                    IsValid = false,
                    ErrorMessage = "Point должен содержать ровно 2 координаты (longitude, latitude)"
                };
            }
        }

        return new ValidationResult { IsValid = true };
    }

    private Participant? CreateParticipantFromFeature(GeoJsonFeature? feature)
    {
        if (feature == null || feature.Geometry == null)
            return null;

        try
        {
            var participant = new Participant
            {
                Id = Guid.NewGuid()
            };

            // Извлекаем свойства
            if (feature.Properties != null)
            {
                if (feature.Properties.TryGetValue("id", out var idValue) && Guid.TryParse(idValue.ToString(), out var id))
                {
                    participant.Id = id;
                }

                if (feature.Properties.TryGetValue("name", out var nameValue))
                    participant.Name = nameValue?.ToString();

                if (feature.Properties.TryGetValue("description", out var descValue))
                    participant.Description = descValue?.ToString();

                if (feature.Properties.TryGetValue("category", out var categoryValue))
                    participant.Category = categoryValue?.ToString();

                if (feature.Properties.TryGetValue("language", out var langValue))
                    participant.Language = langValue?.ToString();

                if (feature.Properties.TryGetValue("country", out var countryValue))
                    participant.Country = countryValue?.ToString();

                if (feature.Properties.TryGetValue("city", out var cityValue))
                    participant.City = cityValue?.ToString();

                if (feature.Properties.TryGetValue("organization", out var orgValue))
                    participant.Organization = orgValue?.ToString();

                if (feature.Properties.TryGetValue("position", out var posValue))
                    participant.Position = posValue?.ToString();

                if (feature.Properties.TryGetValue("email", out var emailValue))
                    participant.Email = emailValue?.ToString();

                if (feature.Properties.TryGetValue("website", out var webValue))
                    participant.Website = webValue?.ToString();

                if (feature.Properties.TryGetValue("interests", out var interestValue))
                    participant.Interests = interestValue?.ToString();

                if (feature.Properties.TryGetValue("skills", out var skillsValue))
                    participant.Skills = skillsValue?.ToString();

                if (feature.Properties.TryGetValue("availability", out var availValue))
                    participant.Availability = availValue?.ToString();

                if (feature.Properties.TryGetValue("tags", out var tagsValue))
                    participant.Tags = tagsValue?.ToString();

                if (feature.Properties.TryGetValue("metadata", out var metaValue))
                    participant.Metadata = metaValue?.ToString();

                if (feature.Properties.TryGetValue("status", out var statusValue) && Enum.TryParse<ParticipantStatus>(statusValue?.ToString(), out var status))
                {
                    participant.Status = status;
                }

                if (feature.Properties.TryGetValue("registrationDate", out var regDateValue) && 
                    DateTime.TryParse(regDateValue?.ToString(), out var regDate))
                {
                    participant.RegistrationDate = regDate;
                }

                if (feature.Properties.TryGetValue("lastActive", out var lastActiveValue) && 
                    DateTime.TryParse(lastActiveValue?.ToString(), out var lastActive))
                {
                    participant.LastActive = lastActive;
                }
            }

            // Извлекаем координаты
            if (feature.Geometry.Type == "Point" && feature.Geometry.Coordinates != null && feature.Geometry.Coordinates.Length >= 2)
            {
                participant.Coordinates = new GeoJsonCoordinates
                {
                    Longitude = feature.Geometry.Coordinates[0],
                    Latitude = feature.Geometry.Coordinates[1]
                };
            }

            return participant;
        }
        catch
        {
            return null;
        }
    }

    private string[]? CalculateBoundingBox(List<GeoJsonFeature> features)
    {
        if (features == null || !features.Any())
            return null;

        double minX = double.MaxValue, minY = double.MaxValue;
        double maxX = double.MinValue, maxY = double.MinValue;

        foreach (var feature in features)
        {
            if (feature.Geometry?.Coordinates != null)
            {
                var coords = feature.Geometry.Coordinates;
                if (coords.Length >= 2)
                {
                    var x = coords[0];
                    var y = coords[1];
                    
                    minX = Math.Min(minX, x);
                    minY = Math.Min(minY, y);
                    maxX = Math.Max(maxX, x);
                    maxY = Math.Max(maxY, y);
                }
            }
        }

        return new[] { minX.ToString(), minY.ToString(), maxX.ToString(), maxY.ToString() };
    }

    private bool IsParticipantInGeoJsonArea(Participant participant, GeoJsonFeatureCollection collection)
    {
        if (participant.Coordinates == null || collection.Features == null)
            return false;

        foreach (var feature in collection.Features)
        {
            if (IsPointInGeometry(participant.Coordinates, feature.Geometry))
            {
                return true;
            }
        }

        return false;
    }

    private bool IsPointInGeometry(GeoJsonCoordinates point, GeoJsonGeometry geometry)
    {
        // Упрощенная проверка - только для Point геометрий
        if (geometry.Type == "Point" && geometry.Coordinates != null && geometry.Coordinates.Length >= 2)
        {
            var geomX = geometry.Coordinates[0];
            var geomY = geometry.Coordinates[1];
            
            // Для точечных геометрий проверяем точное совпадение
            return Math.Abs(point.Longitude - geomX) < 0.0001 && Math.Abs(point.Latitude - geomY) < 0.0001;
        }

        // TODO: Реализовать проверку для других типов геометрий
        return false;
    }

    private async ValueTask<SpatialQueryResult> PerformRadiusQueryAsync(SpatialQuery query, CancellationToken ct)
    {
        // Упрощенная реализация радиального запроса
        // В реальном проекте здесь была бы более сложная геометрическая логика
        var result = new SpatialQueryResult
        {
            Query = query,
            ExecutedAt = DateTime.UtcNow,
            IsSuccess = true
        };

        // Здесь можно использовать библиотеки типа NetTopologySuite для точных расчетов
        await Task.CompletedTask;
        return result;
    }

    private async ValueTask<SpatialQueryResult> PerformBboxQueryAsync(SpatialQuery query, CancellationToken ct)
    {
        var result = new SpatialQueryResult
        {
            Query = query,
            ExecutedAt = DateTime.UtcNow,
            IsSuccess = true
        };

        await Task.CompletedTask;
        return result;
    }

    private async ValueTask<SpatialQueryResult> PerformIntersectsQueryAsync(SpatialQuery query, CancellationToken ct)
    {
        var result = new SpatialQueryResult
        {
            Query = query,
            ExecutedAt = DateTime.UtcNow,
            IsSuccess = true
        };

        await Task.CompletedTask;
        return result;
    }
}

/// <summary>
/// Конфигурация сервиса GeoJSON
/// </summary>
public class GeoJsonServiceConfiguration : IGeoJsonServiceConfiguration
{
    public string? ConnectionString { get; set; }
    public Dictionary<string, object> Settings { get; set; } = new();
    public int TimeoutSeconds { get; set; } = 30;
    public int MaxRetries { get; set; } = 3;
    public int RetryDelayMs { get; set; } = 1000;

    /// <summary>
    /// Источник данных
    /// </summary>
    public string SourceName { get; set; } = "ZealousMindedPeopleGeo";

    /// <summary>
    /// Версия схемы GeoJSON
    /// </summary>
    public string SchemaVersion { get; set; } = "1.0.0";

    /// <summary>
    /// Дополнительные заметки
    /// </summary>
    public string Notes { get; set; } = "";

    /// <summary>
    /// Включить валидацию при чтении
    /// </summary>
    public bool ValidateOnRead { get; set; } = true;

    /// <summary>
    /// Включить сжатие при записи
    /// </summary>
    public bool EnableCompression { get; set; } = false;

    /// <summary>
    /// Максимальный размер файла для обработки (в байтах)
    /// </summary>
    public long MaxFileSizeBytes { get; set; } = 100 * 1024 * 1024; // 100MB

    /// <summary>
    /// Включить подробное логирование
    /// </summary>
    public bool EnableDetailedLogging { get; set; } = false;
}

/// <summary>
/// Статистика сервиса GeoJSON
/// </summary>
public class GeoJsonStatistics : ICloneable
{
    public DateTime LastAnalyzedAt { get; set; }
    public string GeoJsonType { get; set; } = "";
    public int FeatureCount { get; set; }
    public int PointCount { get; set; }
    public int LineStringCount { get; set; }
    public int PolygonCount { get; set; }
    public int MultiPointCount { get; set; }
    public int MultiLineStringCount { get; set; }
    public int MultiPolygonCount { get; set; }
    public int GeometryCollectionCount { get; set; }

    public GeoJsonStatistics Clone()
    {
        return new GeoJsonStatistics
        {
            LastAnalyzedAt = this.LastAnalyzedAt,
            GeoJsonType = this.GeoJsonType,
            FeatureCount = this.FeatureCount,
            PointCount = this.PointCount,
            LineStringCount = this.LineStringCount,
            PolygonCount = this.PolygonCount,
            MultiPointCount = this.MultiPointCount,
            MultiLineStringCount = this.MultiLineStringCount,
            MultiPolygonCount = this.MultiPolygonCount,
            GeometryCollectionCount = this.GeometryCollectionCount
        };
    }

    object ICloneable.Clone() => Clone();
}

/// <summary>
/// Аргументы события GeoJSON
/// </summary>
public class GeoJsonEventArgs : EventArgs
{
    public string OperationId { get; }
    public string? Description { get; }
    public object? Data { get; }

    public GeoJsonEventArgs(string operationId, string? description = null, object? data = null)
    {
        OperationId = operationId;
        Description = description;
        Data = data;
    }
}

/// <summary>
/// Аргументы ошибки GeoJSON
/// </summary>
public class GeoJsonErrorEventArgs : EventArgs
{
    public string OperationId { get; }
    public string Description { get; }
    public string ErrorMessage { get; }
    public Exception? Exception { get; }

    public GeoJsonErrorEventArgs(string operationId, string description, string errorMessage, Exception? exception = null)
    {
        OperationId = operationId;
        Description = description;
        ErrorMessage = errorMessage;
        Exception = exception;
    }
}