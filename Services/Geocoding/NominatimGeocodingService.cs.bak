using System.Net.Http.Json;
using System.Text.Json;
using ZealousMindedPeopleGeo.Models;
using ZealousMindedPeopleGeo.Interfaces;
using System.Collections.Concurrent;

namespace ZealousMindedPeopleGeo.Services.Geocoding;

/// <summary>
/// Сервис геокодирования на основе Nominatim OpenStreetMap API
/// </summary>
public class NominatimGeocodingService : IGeocodingService, IDisposable
{
    private readonly HttpClient _httpClient;
    private readonly object _lock = new();
    private readonly NominatimGeocodingConfiguration _configuration;
    private readonly ConcurrentDictionary<string, GeocodingCacheEntry> _cache = new();
    private readonly GeocodingStatistics _statistics;

    public string Name => "Nominatim OpenStreetMap Geocoding";
    public string Description => "Бесплатное геокодирование через OpenStreetMap Nominatim API";
    public GeocodingServiceType ServiceType => GeocodingServiceType.Nominatim;
    public IGeocodingConfiguration Configuration => _configuration;

    public event EventHandler<GeocodingEventArgs>? GeocodingStarted;
    public event EventHandler<GeocodingEventArgs>? GeocodingCompleted;
    public event EventHandler<GeocodingErrorEventArgs>? GeocodingError;
    public event EventHandler<RateLimitEventArgs>? RateLimitExceeded;

    public NominatimGeocodingService(NominatimGeocodingConfiguration? config = null)
    {
        _configuration = config ?? new NominatimGeocodingConfiguration();
        _statistics = new GeocodingStatistics();

        _httpClient = new HttpClient
        {
            Timeout = TimeSpan.FromSeconds(_configuration.TimeoutSeconds)
        };

        // Устанавливаем заголовки для Nominatim API
        _httpClient.DefaultRequestHeaders.Add("User-Agent", _configuration.UserAgent);
        _httpClient.DefaultRequestHeaders.Add("Accept-Language", _configuration.Language);
    }

    /// <summary>
    /// Геокодирует адрес в координаты
    /// </summary>
    public async ValueTask<GeocodingResult> GeocodeAsync(string address, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        if (string.IsNullOrWhiteSpace(address))
            throw new ArgumentException("Адрес не может быть пустым", nameof(address));

        var operationId = Guid.NewGuid().ToString();
        var startTime = DateTime.UtcNow;

        GeocodingStarted?.Invoke(this, new GeocodingEventArgs(operationId, address));

        try
        {
            // Проверяем кэш
            if (TryGetFromCache(address, out var cachedResult))
            {
                _statistics.CacheHits++;
                return cachedResult;
            }

            // Проверяем лимиты запросов
            await CheckRateLimitAsync(ct);

            // Выполняем запрос к Nominatim API
            var coordinates = await PerformGeocodingRequestAsync(address, ct);

            var result = new GeocodingResult
            {
                IsSuccess = true,
                Address = address,
                Coordinates = coordinates,
                FormattedAddress = coordinates?.DisplayName,
                Provider = "Nominatim",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            // Кэшируем результат
            AddToCache(address, result);

            _statistics.SuccessfulRequests++;
            GeocodingCompleted?.Invoke(this, new GeocodingEventArgs(operationId, address, coordinates));

            return result;
        }
        catch (HttpRequestException ex)
        {
            _statistics.FailedRequests++;
            var errorResult = new GeocodingResult
            {
                IsSuccess = false,
                Address = address,
                ErrorMessage = $"Ошибка сети: {ex.Message}",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            GeocodingError?.Invoke(this, new GeocodingErrorEventArgs(operationId, address, ex.Message, ex));
            return errorResult;
        }
        catch (TaskCanceledException ex) when (ex.InnerException is TimeoutException)
        {
            _statistics.FailedRequests++;
            var errorResult = new GeocodingResult
            {
                IsSuccess = false,
                Address = address,
                ErrorMessage = "Превышено время ожидания запроса",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            GeocodingError?.Invoke(this, new GeocodingErrorEventArgs(operationId, address, "Превышено время ожидания", ex));
            return errorResult;
        }
        catch (RateLimitExceededException ex)
        {
            _statistics.RateLimitExceeded++;
            var errorResult = new GeocodingResult
            {
                IsSuccess = false,
                Address = address,
                ErrorMessage = "Превышен лимит запросов",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            RateLimitExceeded?.Invoke(this, new RateLimitEventArgs(operationId, address, ex.RetryAfter));
            return errorResult;
        }
        catch (Exception ex)
        {
            _statistics.FailedRequests++;
            var errorResult = new GeocodingResult
            {
                IsSuccess = false,
                Address = address,
                ErrorMessage = $"Неожиданная ошибка: {ex.Message}",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            GeocodingError?.Invoke(this, new GeocodingErrorEventArgs(operationId, address, ex.Message, ex));
            return errorResult;
        }
    }

    /// <summary>
    /// Обратное геокодирование - координаты в адрес
    /// </summary>
    public async ValueTask<GeocodingResult> ReverseGeocodeAsync(GeoJsonCoordinates coordinates, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        if (coordinates == null)
            throw new ArgumentNullException(nameof(coordinates));

        var operationId = Guid.NewGuid().ToString();
        var startTime = DateTime.UtcNow;
        var cacheKey = $"reverse_{coordinates.Latitude:F6}_{coordinates.Longitude:F6}";

        GeocodingStarted?.Invoke(this, new GeocodingEventArgs(operationId, $"({coordinates.Latitude}, {coordinates.Longitude})"));

        try
        {
            // Проверяем кэш
            if (TryGetFromCache(cacheKey, out var cachedResult))
            {
                _statistics.CacheHits++;
                return cachedResult;
            }

            // Проверяем лимиты запросов
            await CheckRateLimitAsync(ct);

            // Выполняем запрос к Nominatim API
            var address = await PerformReverseGeocodingRequestAsync(coordinates, ct);

            var result = new GeocodingResult
            {
                IsSuccess = true,
                Address = address?.DisplayName,
                Coordinates = coordinates,
                FormattedAddress = address?.DisplayName,
                Provider = "Nominatim",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            // Кэшируем результат
            AddToCache(cacheKey, result);

            _statistics.SuccessfulRequests++;
            GeocodingCompleted?.Invoke(this, new GeocodingEventArgs(operationId, address?.DisplayName, coordinates));

            return result;
        }
        catch (HttpRequestException ex)
        {
            _statistics.FailedRequests++;
            var errorResult = new GeocodingResult
            {
                IsSuccess = false,
                Coordinates = coordinates,
                ErrorMessage = $"Ошибка сети: {ex.Message}",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            GeocodingError?.Invoke(this, new GeocodingErrorEventArgs(operationId, coordinates.ToString(), ex.Message, ex));
            return errorResult;
        }
        catch (Exception ex)
        {
            _statistics.FailedRequests++;
            var errorResult = new GeocodingResult
            {
                IsSuccess = false,
                Coordinates = coordinates,
                ErrorMessage = $"Неожиданная ошибка: {ex.Message}",
                OperationId = operationId,
                ExecutionTime = DateTime.UtcNow - startTime
            };

            GeocodingError?.Invoke(this, new GeocodingErrorEventArgs(operationId, coordinates.ToString(), ex.Message, ex));
            return errorResult;
        }
    }

    /// <summary>
    /// Пакетное геокодирование
    /// </summary>
    public async ValueTask<IEnumerable<GeocodingResult>> GeocodeBatchAsync(IEnumerable<string> addresses, int maxConcurrency = 5, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        if (addresses == null)
            throw new ArgumentNullException(nameof(addresses));

        var addressList = addresses.ToList();
        if (!addressList.Any())
            return Enumerable.Empty<GeocodingResult>();

        // Ограничиваем количество одновременных запросов
        var semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency);
        var results = new List<GeocodingResult>();
        var tasks = addressList.Select(async address =>
        {
            await semaphore.WaitAsync(ct);
            try
            {
                return await GeocodeAsync(address, ct);
            }
            finally
            {
                semaphore.Release();
            }
        });

        results.AddRange(await Task.WhenAll(tasks));
        return results;
    }

    /// <summary>
    /// Валидирует адрес перед геокодированием
    /// </summary>
    public bool ValidateAddress(string address)
    {
        if (string.IsNullOrWhiteSpace(address))
            return false;

        // Базовая валидация адреса
        var trimmed = address.Trim();
        
        // Минимальная длина адреса
        if (trimmed.Length < 3)
            return false;

        // Адрес не должен состоять только из цифр
        if (trimmed.All(char.IsDigit))
            return false;

        // Адрес не должен содержать только специальные символы
        if (trimmed.All(c => !char.IsLetterOrDigit(c)))
            return false;

        return true;
    }

    /// <summary>
    /// Получает статистику сервиса геокодирования
    /// </summary>
    public GeocodingStatistics GetStatistics()
    {
        lock (_lock)
        {
            return _statistics.Clone();
        }
    }

    /// <summary>
    /// Очищает кэш геокодирования
    /// </summary>
    public void ClearCache()
    {
        lock (_lock)
        {
            _cache.Clear();
        }
    }

    /// <summary>
    /// Получает информацию о кэше
    /// </summary>
    public CacheInfo GetCacheInfo()
    {
        lock (_lock)
        {
            return new CacheInfo
            {
                TotalEntries = _cache.Count,
                CacheHits = _statistics.CacheHits,
                CacheHitRate = _statistics.TotalRequests > 0 
                    ? (double)_statistics.CacheHits / _statistics.TotalRequests * 100 
                    : 0
            };
        }
    }

    private async Task<GeoJsonCoordinates> PerformGeocodingRequestAsync(string address, CancellationToken ct)
    {
        var encodedAddress = Uri.EscapeDataString(address);
        var url = $"{_configuration.ApiBaseUrl}search?q={encodedAddress}&format=json&limit=1&addressdetails=1";

        if (!string.IsNullOrEmpty(_configuration.CountryCodes))
            url += $"&countrycodes={_configuration.CountryCodes}";

        var response = await _httpClient.GetAsync(url, ct);
        
        if (response.StatusCode == System.Net.HttpStatusCode.TooManyRequests)
        {
            var retryAfter = response.Headers.RetryAfter?.Delta?.TotalSeconds ?? _configuration.RetryDelaySeconds;
            throw new RateLimitExceededException($"Rate limit exceeded. Retry after {retryAfter} seconds", retryAfter);
        }

        response.EnsureSuccessStatusCode();

        var responseContent = await response.Content.ReadAsStringAsync(ct);
        var results = JsonSerializer.Deserialize<List<NominatimResponse>>(responseContent);

        if (results == null || !results.Any())
            throw new InvalidOperationException("Геокодирование не вернуло результатов");

        var result = results.First();
        return new GeoJsonCoordinates
        {
            Longitude = result.Lon,
            Latitude = result.Lat,
            DisplayName = result.DisplayName
        };
    }

    private async Task<NominatimAddress?> PerformReverseGeocodingRequestAsync(GeoJsonCoordinates coordinates, CancellationToken ct)
    {
        var url = $"{_configuration.ApiBaseUrl}reverse?lat={coordinates.Latitude}&lon={coordinates.Longitude}&format=json&addressdetails=1";

        var response = await _httpClient.GetAsync(url, ct);
        
        if (response.StatusCode == System.Net.HttpStatusCode.TooManyRequests)
        {
            var retryAfter = response.Headers.RetryAfter?.Delta?.TotalSeconds ?? _configuration.RetryDelaySeconds;
            throw new RateLimitExceededException($"Rate limit exceeded. Retry after {retryAfter} seconds", retryAfter);
        }

        response.EnsureSuccessStatusCode();

        var responseContent = await response.Content.ReadAsStringAsync(ct);
        var result = JsonSerializer.Deserialize<NominatimAddress>(responseContent);

        return result;
    }

    private async Task CheckRateLimitAsync(CancellationToken ct)
    {
        // Проверяем глобальный лимит
        await Task.Delay(_configuration.MinDelayBetweenRequestsMs, ct);
        
        // В реальной реализации здесь можно добавить более сложную логику
        // ограничения количества запросов в единицу времени
    }

    private bool TryGetFromCache(string key, out GeocodingResult result)
    {
        result = null!;
        
        if (_cache.TryGetValue(key, out var entry) && entry.IsValid)
        {
            result = entry.Result;
            return true;
        }

        return false;
    }

    private void AddToCache(string key, GeocodingResult result)
    {
        var entry = new GeocodingCacheEntry
        {
            Result = result,
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.Add(_configuration.CacheExpiration)
        };

        _cache[key] = entry;

        // Очищаем кэш если он стал слишком большим
        if (_cache.Count > _configuration.MaxCacheSize)
        {
            CleanupExpiredCacheEntries();
        }
    }

    private void CleanupExpiredCacheEntries()
    {
        var now = DateTime.UtcNow;
        var expiredKeys = _cache.Where(kvp => kvp.Value.ExpiresAt <= now)
                               .Select(kvp => kvp.Key)
                               .ToList();

        foreach (var key in expiredKeys)
        {
            _cache.TryRemove(key, out _);
        }

        // Если кэш все еще слишком большой, удаляем самые старые записи
        if (_cache.Count > _configuration.MaxCacheSize * 0.8)
        {
            var sortedEntries = _cache.OrderBy(kvp => kvp.Value.CreatedAt)
                                    .Take(_configuration.MaxCacheSize / 2)
                                    .ToList();

            foreach (var entry in sortedEntries)
            {
                _cache.TryRemove(entry.Key, out _);
            }
        }
    }

    public void Dispose()
    {
        _httpClient?.Dispose();
    }
}

/// <summary>
/// Ответ от Nominatim API
/// </summary>
internal class NominatimResponse
{
    public double Lat { get; set; }
    public double Lon { get; set; }
    public string DisplayName { get; set; } = "";
    public string Type { get; set; } = "";
    public string Importance { get; set; } = "";
}

/// <summary>
/// Адрес от Nominatim API
/// </summary>
internal class NominatimAddress
{
    public string? HouseNumber { get; set; }
    public string? Road { get; set; }
    public string? Village { get; set; }
    public string? Town { get; set; }
    public string? City { get; set; }
    public string? County { get; set; }
    public string? State { get; set; }
    public string? Country { get; set; }
    public string? CountryCode { get; set; }
    public string DisplayName { get; set; } = "";
}

/// <summary>
/// Запись кэша геокодирования
/// </summary>
internal class GeocodingCacheEntry
{
    public GeocodingResult Result { get; set; } = null!;
    public DateTime CreatedAt { get; set; }
    public DateTime ExpiresAt { get; set; }
    public bool IsValid => DateTime.UtcNow <= ExpiresAt;
}

/// <summary>
/// Исключение превышения лимита запросов
/// </summary>
public class RateLimitExceededException : Exception
{
    public double RetryAfter { get; }

    public RateLimitExceededException(string message, double retryAfter) : base(message)
    {
        RetryAfter = retryAfter;
    }
}

/// <summary>
/// Конфигурация сервиса Nominatim геокодирования
/// </summary>
public class NominatimGeocodingConfiguration : IGeocodingConfiguration
{
    public string? ConnectionString { get; set; }
    public Dictionary<string, object> Settings { get; set; } = new();
    public int TimeoutSeconds { get; set; } = 30;
    public int MaxRetries { get; set; } = 3;
    public int RetryDelayMs { get; set; } = 1000;

    /// <summary>
    /// Базовый URL Nominatim API
    /// </summary>
    public string ApiBaseUrl { get; set; } = "https://nominatim.openstreetmap.org/";

    /// <summary>
    /// User-Agent для запросов к API
    /// </summary>
    public string UserAgent { get; set; } = "ZealousMindedPeopleGeo/1.0 (Contact: contact@example.com)";

    /// <summary>
    /// Язык для результатов геокодирования
    /// </summary>
    public string Language { get; set; } = "ru,en";

    /// <summary>
    /// Коды стран для ограничения поиска (через запятую)
    /// </summary>
    public string CountryCodes { get; set; } = "";

    /// <summary>
    /// Минимальная задержка между запросами в миллисекундах
    /// </summary>
    public int MinDelayBetweenRequestsMs { get; set; } = 1000;

    /// <summary>
    /// Время жизни кэша
    /// </summary>
    public TimeSpan CacheExpiration { get; set; } = TimeSpan.FromHours(24);

    /// <summary>
    /// Максимальный размер кэша
    /// </summary>
    public int MaxCacheSize { get; set; } = 10000;

    /// <summary>
    /// Включить подробное логирование
    /// </summary>
    public bool EnableDetailedLogging { get; set; } = false;

    /// <summary>
    /// Включить кэширование
    /// </summary>
    public bool EnableCaching { get; set; } = true;

    /// <summary>
    /// Задержка между повторными попытками (в секундах)
    /// </summary>
    public int RetryDelaySeconds { get; set; } = 2;
}